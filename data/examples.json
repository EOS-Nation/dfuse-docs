{
  "quickstarts_go_eos_section1": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\tpb \"github.com/dfuse-io/docs/quickstarts/go/pb\"\n\t\"github.com/tidwall/gjson\"\n\t\"golang.org/x/oauth2\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/oauth\"\n)\n",
  "quickstarts_go_eos_section2": "func getToken(apiKey string) (token string, expiration time.Time, err error) {\n\treqBody := bytes.NewBuffer([]byte(fmt.Sprintf(`{\"api_key\":\"%s\"}`, apiKey)))\n\tresp, err := http.Post(\"https://auth.eosnation.io/v1/auth/issue\", \"application/json\", reqBody)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to obtain token: %s\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\terr = fmt.Errorf(\"unable to obtain token, status not 200, got %d: %s\", resp.StatusCode, reqBody.String())\n\t\treturn\n\t}\n\n\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\ttoken = gjson.GetBytes(body, \"token\").String()\n\t\texpiration = time.Unix(gjson.GetBytes(body, \"expires_at\").Int(), 0)\n\t}\n\treturn\n}\n",
  "quickstarts_go_eos_section3": "func createClient(endpoint string) pb.GraphQLClient {\n\tdfuseAPIKey := os.Getenv(\"DFUSE_API_KEY\")\n\tif dfuseAPIKey == \"\" {\n\t\tpanic(\"you must specify a DFUSE_API_KEY environment variable\")\n\t}\n\n\ttoken, _, err := getToken(dfuseAPIKey)\n\tpanicIfError(err)\n\n\tcredential := oauth.NewOauthAccess(&oauth2.Token{AccessToken: token, TokenType: \"Bearer\"})\n\ttransportCreds := credentials.NewClientTLSFromCert(nil, \"\")\n\tconn, err := grpc.Dial(endpoint,\n\t\tgrpc.WithPerRPCCredentials(credential),\n\t\tgrpc.WithTransportCredentials(transportCreds),\n\t)\n\tpanicIfError(err)\n\n\treturn pb.NewGraphQLClient(conn)\n}\n",
  "quickstarts_go_eos_section4": "const operationEOS = `subscription {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\") {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`\n\ntype eosioDocument struct {\n\tSearchTransactionsForward struct {\n\t\tCursor string\n\t\tUndo   bool\n\t\tTrace  struct {\n\t\t\tID              string\n\t\t\tMatchingActions []struct {\n\t\t\t\tJSON map[string]interface{}\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "quickstarts_go_eos_section5": "func streamEOSIO(ctx context.Context) {\n\t/* The client can be re-used for all requests, cache it at the appropriate level */\n\tclient := createClient(\"eos.dfuse.eosnation.io:9000\")\n\texecutor, err := client.Execute(ctx, &pb.Request{Query: operationEOS})\n\tpanicIfError(err)\n\n\tfor {\n\t\tresp, err := executor.Recv()\n\t\tpanicIfError(err)\n\n\t\tif len(resp.Errors) > 0 {\n\t\t\tfor _, err := range resp.Errors {\n\t\t\t\tfmt.Printf(\"Request failed: %s\\n\", err)\n\t\t\t}\n\n\t\t\t/* We continue here, but you could take another decision here, like exiting the process */\n\t\t\tcontinue\n\t\t}\n\n\t\tdocument := &eosioDocument{}\n\t\terr = json.Unmarshal([]byte(resp.Data), document)\n\t\tpanicIfError(err)\n\n\t\tresult := document.SearchTransactionsForward\n\t\treverted := \"\"\n\t\tif result.Undo {\n\t\t\treverted = \" REVERTED\"\n\t\t}\n\n\t\tfor _, action := range result.Trace.MatchingActions {\n\t\t\tdata := action.JSON\n\t\t\tfmt.Printf(\"Transfer %s -> %s [%s]%s\\n\", data[\"from\"], data[\"to\"], data[\"quantity\"], reverted)\n\t\t}\n\t}\n}\n",
  "quickstarts_javascript_browser_eos_section1": "<head>\n    <style> li { font-family: monospace; margin: 0.15; }</style>\n    <script src=\"https://unpkg.com/@dfuse/client\"></script>\n    <script>\n        const client = dfuseClient.createDfuseClient({\n          // Replace 'web_abcdef12345678900000000000' with your own API key!\n          apiKey: 'web_abcdef12345678900000000000',\n          network: 'eos.dfuse.eosnation.io'\n        })\n    </script>\n</head>",
  "quickstarts_javascript_browser_eos_section2": "<script>\n// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`\n</script>",
  "quickstarts_javascript_browser_eos_section3": "<script>\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, trace: { id, matchingActions }} = message.data.searchTransactionsForward\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${quantity}]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}\n</script>",
  "quickstarts_javascript_browser_eos_section4": "<script>\nmain().catch((error) => document.body.innerHTML = `<p>${error}</p>`)\n</script>",
  "quickstarts_javascript_bundler_eos_section1": "import { createDfuseClient } from \"@dfuse/client\"\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"eos.dfuse.eosnation.io\",\n})",
  "quickstarts_javascript_bundler_eos_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`",
  "quickstarts_javascript_bundler_eos_section3": "// You would normally use your framework entry point and render using components,\n// we are using pure HTML manipulation for sake of example simplicity.\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, trace: { id, matchingActions }} = message.data.searchTransactionsForward\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${quantity}]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_bundler_eos_section4": "main().catch((error) => document.body.innerHTML = `<p>${error}</p>`)",
  "quickstarts_javascript_node_eos_section1": "const { createDfuseClient } = require('@dfuse/client');\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: 'eos.dfuse.eosnation.io'\n});",
  "quickstarts_javascript_node_eos_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`;",
  "quickstarts_javascript_node_eos_section3": "async function main() {\n  const stream = await client.graphql(operation, message => {\n    if (message.type === 'data') {\n      const {\n        undo,\n        cursor,\n        trace: { id, matchingActions }\n      } = message.data.searchTransactionsForward;\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        console.log(\n          `Transfer ${from} -> ${to} [${quantity}]${undo ? ' REVERTED' : ''}`\n        );\n      });\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor });\n    }\n\n    if (message.type === 'error') {\n      console.log('An error occurred', message.errors, message.terminal);\n    }\n\n    if (message.type === 'complete') {\n      console.log('Completed');\n    }\n  });\n\n  // Waits until the stream completes, or forever\n  await stream.join();\n  await client.release();\n}",
  "quickstarts_javascript_node_eos_section4": "main().catch(error => console.log('Unexpected error', error));",
  "quickstarts_python_eos_section1": "try:\n    # python3\n    from http.client import HTTPSConnection\nexcept ImportError:\n    # python2\n    from httplib import HTTPSConnection\n\nimport grpc\nimport json\nimport os\nimport ssl\nimport sys\n\nfrom graphql import graphql_pb2_grpc\nfrom graphql.graphql_pb2 import Request",
  "quickstarts_python_eos_section2": "def get_token(api_key):\n    connection = HTTPSConnection(\"auth.eosnation.io\")\n    connection.request('POST', '/v1/auth/issue', json.dumps({\"api_key\": api_key}), {'Content-type': 'application/json'})\n    response = connection.getresponse()\n\n    if response.status != 200:\n        raise Exception(\" Status: %s reason: %s\" % (response.status, response.reason))\n\n    token = json.loads(response.read().decode())['token']\n    connection.close()\n\n    return token",
  "quickstarts_python_eos_section3": "def create_client(endpoint):\n    dfuse_api_key = os.environ.get(\"DFUSE_API_KEY\")\n    if dfuse_api_key == None:\n        raise Exception(\"you must specify a DFUSE_API_KEY environment variable\")\n\n    channel = grpc.secure_channel(endpoint,\n        credentials = grpc.composite_channel_credentials(\n            grpc.ssl_channel_credentials(),\n            grpc.access_token_call_credentials(get_token(dfuse_api_key))\n    ))\n\n    return graphql_pb2_grpc.GraphQLStub(channel)",
  "quickstarts_python_eos_section4": "OPERATION_EOS = \"\"\"subscription {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer\") {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}\"\"\"",
  "quickstarts_python_eos_section5": "def stream_eosio():\n  \t# The client can be re-used for all requests, cache it at the appropriate level\n    client = create_client('eos.dfuse.eosnation.io:9000')\n    stream = client.Execute(Request(query = OPERATION_EOS))\n\n    for rawResult in stream:\n        if rawResult.errors:\n            print(\"An error occurred\")\n            print(rawResult.errors)\n        else:\n            result = json.loads(rawResult.data)\n            for action in result['searchTransactionsForward']['trace']['matchingActions']:\n                undo = result['searchTransactionsForward']['undo']\n                data = action['json']\n                print(\"Transfer %s -> %s [%s]%s\" % (data['from'], data['to'], data['quantity'], \" REVERTED\" if undo else \"\"))",
  "tutorials_eos_push-guaranteed_section1": "import { Api, JsonRpc } from \"eosjs\"\nimport { JsSignatureProvider } from \"eosjs/dist/eosjs-jssig\"\nimport { TextDecoder, TextEncoder } from \"text-encoding\"",
  "tutorials_eos_push-guaranteed_section2": "import fetch, { Request, RequestInit, Response } from \"node-fetch\"",
  "tutorials_eos_push-guaranteed_section3": "import { createDfuseClient } from \"@dfuse/client\"\n;(global as any).fetch = fetch\n;(global as any).WebSocket = {}\n\nconst config = readConfig()\nconst client = createDfuseClient({ apiKey: config.dfuseApiKey, network: config.network })",
  "tutorials_eos_push-guaranteed_section4": "const customizedFetch = async (input?: string | Request, init?: RequestInit): Promise<Response> => {\n  if (init === undefined) {\n    init = {}\n  }\n\n  if (init.headers === undefined) {\n    init.headers = {}\n  }\n\n  // This is highly optimized and cached, so while the token is fresh, this is very fast\n  const apiTokenInfo = await client.getTokenInfo()\n\n  const headers = init.headers as { [name: string]: string }\n  headers[\"Authorization\"] = `Bearer ${apiTokenInfo.token}`\n  headers[\"X-Eos-Push-Guarantee\"] = config.guaranteed\n\n  return fetch(input!, init)\n}",
  "tutorials_eos_push-guaranteed_section5": "async function main() {\n  const signatureProvider = new JsSignatureProvider([config.privateKey])\n  const rpc = new JsonRpc(client.endpoints.restUrl, { fetch: customizedFetch as any })\n  const api = new Api({\n    rpc,\n    signatureProvider,\n    textDecoder: new TextDecoder(),\n    textEncoder: new TextEncoder()\n  })\n\n  const transferAction = {\n    account: \"eosio.token\",\n    name: \"transfer\",\n    authorization: [\n      {\n        actor: config.transferFrom,\n        permission: \"active\"\n      }\n    ],\n    data: {\n      from: config.transferFrom,\n      to: config.transferTo,\n      quantity: config.transferQuantity,\n      memo: `Transaction with push guaranteed '${\n        config.guaranteed\n      }' from dfuse (https://docs.dfuse.eosnation.io/#rest-api-post-push_transaction)`\n    }\n  }\n\n  console.log(\"Transfer action\", prettyJson(transferAction))\n\n  const startTime = new Date()\n  const result = await api.transact(\n    { actions: [transferAction] },\n    {\n      blocksBehind: 360,\n      expireSeconds: 3600\n    }\n  )\n  const endTime = new Date()\n\n  printResult(result, startTime, endTime)\n}",
  "tutorials_eos_push-guaranteed_section6": "function readConfig() {\n  const network = process.env.DFUSE_API_NETWORK || \"kylin.dfuse.eosnation.io\"\n  const guaranteed = process.env.PUSH_GUARANTEED || \"in-block\" // Or \"irreversible\", \"handoff:1\", \"handoffs:2\", \"handoffs:3\"\n  const transferTo = process.env.TRANSFER_TO_ACCOUNT || \"eoscanadacom\"\n  const transferQuantity = process.env.TRANSFER_QUANTITY || \"0.0001 EOS\"\n\n  const dfuseApiKey = process.env.DFUSE_API_KEY\n  if (dfuseApiKey === undefined) {\n    console.log(\n      \"You must have a 'process.env.DFUSE_API_KEY' environment variable containing your dfuse API key.\"\n    )\n    process.exit(1)\n  }\n\n  const privateKey = process.env.SIGNING_PRIVATE_KEY\n  if (privateKey === undefined) {\n    console.log(\n      \"You must have a 'SIGNING_PRIVATE_KEY' environment variable containing private used to sign.\"\n    )\n    process.exit(1)\n  }\n\n  const transferFrom = process.env.TRANSFER_FROM_ACCOUNT\n  if (transferFrom === undefined) {\n    console.log(\n      \"You must have a 'TRANSFER_FROM_ACCOUNT' environment variable containing account that is going to send token.\"\n    )\n    process.exit(1)\n  }\n\n  return {\n    network,\n    guaranteed,\n    dfuseApiKey: dfuseApiKey!,\n    privateKey: privateKey!,\n    transferFrom: transferFrom!,\n    transferTo,\n    transferQuantity\n  }\n}\n\nfunction printResult(result: any, startTime: Date, endTime: Date) {\n  console.log(\"Transaction push result\", prettyJson(result))\n  console.log()\n\n  const elapsed = (endTime.getTime() - startTime.getTime()) / 1000.0\n  console.log(`Pushed with guarenteed '${config.guaranteed}' in '${elapsed}' seconds`)\n\n  const networkMatch = client.endpoints.restUrl.match(\n    /https:\\/\\/(eos|wax|testnet|kylin|jungle).dfuse.eosnation.io/\n  )\n  if (networkMatch !== null && networkMatch[1] != null) {\n    let network = networkMatch[1]\n    console.log(` - https://${network}.eosq.eosnation.io/tx/${result.transaction_id}`)\n  }\n}\n\nfunction prettyJson(input: any): string {\n  return JSON.stringify(input, null, 2)\n}\n\nmain()\n  .then(() => {\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.log(\"An error occurred.\", prettyJson(error))\n    process.exit(1)\n  })"
}
